From bd283ef8b9ed6c5efaf1d6bba96c105b0410ab65 Mon Sep 17 00:00:00 2001
From: Adrian Reber <areber@redhat.com>
Date: Mon, 16 Dec 2019 07:57:03 +0000
Subject: [PATCH] Add assembler wrapper for clone3()

To create a new process/thread with a certain PID based on clone3() a
new assembler wrapper is necessary as there is not glibc wrapper (yet).

Signed-off-by: Adrian Reber <areber@redhat.com>
Signed-off-by: Sang Yan <sangyan@huawei.com>
---
 criu/arch/aarch64/include/asm/restorer.h |  7 +++
 criu/arch/arm/include/asm/restorer.h     |  7 +++
 criu/arch/ppc64/include/asm/restorer.h   |  7 +++
 criu/arch/s390/include/asm/restorer.h    |  7 +++
 criu/arch/x86/include/asm/restorer.h     | 92 ++++++++++++++++++++++++++++++++
 5 files changed, 120 insertions(+)

diff --git a/criu/arch/aarch64/include/asm/restorer.h b/criu/arch/aarch64/include/asm/restorer.h
index f502cdc..2fe5891 100644
--- a/criu/arch/aarch64/include/asm/restorer.h
+++ b/criu/arch/aarch64/include/asm/restorer.h
@@ -42,6 +42,13 @@
 			  "r"(&thread_args[i])					\
 			: "x0", "x1", "x2", "x3", "x8", "memory")
 
+#define RUN_CLONE3_RESTORE_FN(ret, clone_args, size, args, \
+			      clone_restore_fn)	do { \
+	pr_err("This architecture does not support clone3() with set_tid, yet!\n"); \
+	pr_err("Not creating a process with PID: %d\n", ((pid_t *)u64_to_ptr(clone_args.set_tid))[0]); \
+	ret = -1; \
+} while (0)
+
 #define ARCH_FAIL_CORE_RESTORE					\
 	asm volatile(						\
 			"mov sp, %0			\n"	\
diff --git a/criu/arch/arm/include/asm/restorer.h b/criu/arch/arm/include/asm/restorer.h
index 217d920..ad4b58f 100644
--- a/criu/arch/arm/include/asm/restorer.h
+++ b/criu/arch/arm/include/asm/restorer.h
@@ -43,6 +43,13 @@
 		       "r"(&thread_args[i])				\
 		     : "r0", "r1", "r2", "r3", "r7", "memory")
 
+#define RUN_CLONE3_RESTORE_FN(ret, clone_args, size, args, \
+			      clone_restore_fn)	do { \
+	pr_err("This architecture does not support clone3() with set_tid, yet!\n"); \
+	pr_err("Not creating a process with PID: %d\n", ((pid_t *)u64_to_ptr(clone_args.set_tid))[0]); \
+	ret = -1; \
+} while (0)
+
 #define ARCH_FAIL_CORE_RESTORE					\
 	asm volatile(						\
 		     "mov sp, %0			\n"	\
diff --git a/criu/arch/ppc64/include/asm/restorer.h b/criu/arch/ppc64/include/asm/restorer.h
index d48d833..19bc3ea 100644
--- a/criu/arch/ppc64/include/asm/restorer.h
+++ b/criu/arch/ppc64/include/asm/restorer.h
@@ -48,6 +48,13 @@
 		  "r"(&thread_args[i])		/* %6 */		\
 		: "memory","0","3","4","5","6","7","14","15")
 
+#define RUN_CLONE3_RESTORE_FN(ret, clone_args, size, args, \
+			      clone_restore_fn)	do { \
+	pr_err("This architecture does not support clone3() with set_tid, yet!\n"); \
+	pr_err("Not creating a process with PID: %d\n", ((pid_t *)u64_to_ptr(clone_args.set_tid))[0]); \
+	ret = -1; \
+} while (0)
+
 #define arch_map_vdso(map, compat)		-1
 
 int restore_gpregs(struct rt_sigframe *f, UserPpc64RegsEntry *r);
diff --git a/criu/arch/s390/include/asm/restorer.h b/criu/arch/s390/include/asm/restorer.h
index cfdefca..733f2de 100644
--- a/criu/arch/s390/include/asm/restorer.h
+++ b/criu/arch/s390/include/asm/restorer.h
@@ -39,6 +39,13 @@
 	  "d"(&thread_args[i])						\
 	: "0", "1", "2", "3", "4", "5", "6", "cc", "memory")
 
+#define RUN_CLONE3_RESTORE_FN(ret, clone_args, size, args, \
+			      clone_restore_fn)	do { \
+	pr_err("This architecture does not support clone3() with set_tid, yet!\n"); \
+	pr_err("Not creating a process with PID: %d\n", ((pid_t *)u64_to_ptr(clone_args.set_tid))[0]); \
+	ret = -1; \
+} while (0)
+
 #define arch_map_vdso(map, compat)		-1
 
 int restore_gpregs(struct rt_sigframe *f, UserS390RegsEntry *r);
diff --git a/criu/arch/x86/include/asm/restorer.h b/criu/arch/x86/include/asm/restorer.h
index 25559b5..731477e 100644
--- a/criu/arch/x86/include/asm/restorer.h
+++ b/criu/arch/x86/include/asm/restorer.h
@@ -25,6 +25,21 @@ static inline int set_compat_robust_list(uint32_t head_ptr, uint32_t len)
 }
 #endif /* !CONFIG_COMPAT */
 
+/*
+ * Documentation copied from glibc sysdeps/unix/sysv/linux/x86_64/clone.S
+ * The kernel expects:
+ * rax: system call number
+ * rdi: flags
+ * rsi: child_stack
+ * rdx: TID field in parent
+ * r10: TID field in child
+ * r8:	thread pointer
+ *
+ * int clone(unsigned long clone_flags, unsigned long newsp,
+ *           int *parent_tidptr, int *child_tidptr,
+ *           unsigned long tls);
+ */
+
 #define RUN_CLONE_RESTORE_FN(ret, clone_flags, new_sp, parent_tid,	\
 			     thread_args, clone_restore_fn)		\
 	asm volatile(							\
@@ -63,6 +78,83 @@ static inline int set_compat_robust_list(uint32_t head_ptr, uint32_t len)
 		       "g"(&thread_args[i])				\
 		     : "rax", "rcx", "rdi", "rsi", "rdx", "r10", "r11", "memory")
 
+/* int clone3(struct clone_args *args, size_t size) */
+#define RUN_CLONE3_RESTORE_FN(ret, clone_args, size, args,		\
+			      clone_restore_fn)				\
+	asm volatile(							\
+		     "clone3_emul:				\n"	\
+	/*
+	 * Prepare stack pointer for child process. The kernel does
+	 * stack + stack_size before passing the stack pointer to the
+	 * child process. As we have to put the function and the
+	 * arguments for the new process on that stack we have handle
+	 * the kernel's implicit stack + stack_size.
+	 */								\
+		     "movq (%3), %%rsi	/* new stack pointer */	\n"	\
+	/* Move the stack_size to %rax to use later as the offset */	\
+		     "movq %4, %%rax				\n"	\
+	/* 16 bytes are needed on the stack for function and args */	\
+		     "subq $16, (%%rsi, %%rax)			\n"	\
+		     "movq %6, %%rdi	/* thread args */	\n"	\
+		     "movq %%rdi, 8(%%rsi, %%rax)		\n"	\
+		     "movq %5, %%rdi	/* thread function */	\n"	\
+		     "movq %%rdi, 0(%%rsi, %%rax)		\n"	\
+	/*
+	 * The stack address has been modified for the two
+	 * elements above (child function, child arguments).
+	 * This modified stack needs to be stored back into the
+	 * clone_args structure.
+	 */								\
+		     "movq (%%rsi), %3				\n"	\
+	/*
+	 * Do the actual clone3() syscall. First argument (%rdi) is
+	 * the clone_args structure, second argument is the size
+	 * of clone_args.
+	 */								\
+		     "movq %1, %%rdi	/* clone_args */	\n"	\
+		     "movq %2, %%rsi	/* size */		\n"	\
+		     "movl $"__stringify(__NR_clone3)", %%eax	\n"	\
+		     "syscall					\n"	\
+	/*
+	 * If clone3() was successful and if we are in the child
+	 * '0' is returned. Jump to the child function handler.
+	 */								\
+		     "testq %%rax,%%rax				\n"	\
+		     "jz thread3_run				\n"	\
+	/* Return the PID to the parent process. */			\
+		     "movq %%rax, %0				\n"	\
+		     "jmp clone3_end				\n"	\
+									\
+		     "thread3_run:	/* Child process */	\n"	\
+	/* Clear the frame pointer */					\
+		     "xorq %%rbp, %%rbp				\n"	\
+	/* Pop the child function from the stack */			\
+		     "popq %%rax				\n"	\
+	/* Pop the child function arguments from the stack */		\
+		     "popq %%rdi				\n"	\
+	/* Run the child function */					\
+		     "callq *%%rax				\n"	\
+	/*
+	 * If the child function is expected to return, this
+	 * would be the place to handle the return code. In CRIU's
+	 * case the child function is expected to not return
+	 * and do exit() itself.
+	 */								\
+									\
+		     "clone3_end:				\n"	\
+		     : "=r"(ret)		 			\
+	/*
+	 * This uses the "r" modifier for all parameters
+	 * as clang complained if using "g".
+	 */								\
+		     : "r"(&clone_args),				\
+		       "r"(size),					\
+		       "r"(&clone_args.stack),				\
+		       "r"(clone_args.stack_size),			\
+		       "r"(clone_restore_fn),				\
+		       "r"(args)					\
+		     : "rax", "rcx", "rdi", "rsi", "rdx", "r10", "r11", "memory")
+
 #define ARCH_FAIL_CORE_RESTORE					\
 	asm volatile(						\
 		     "movq %0, %%rsp			    \n"	\
-- 
2.9.5

